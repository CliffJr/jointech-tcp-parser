package jointechparser

import (
	"encoding/hex"
	"fmt"
	"reflect"
	"testing"
	"unicode/utf8"

	"github.com/stretchr/testify/assert"
)

func TestFromAsciiToHexByte(t *testing.T) {
	s := "868822040248195F"
	bs, err := AsciiIMEIToBytes(s)
	assert.Nil(t, err)
	assert.Len(t, bs, len(s)-1)
}

func TestFromNonAsciiToHexByteFailure(t *testing.T) {
	s := "8688220402481995ðŸ§ "
	_, err := AsciiIMEIToBytes(s)
	// should return a conversion error for non UTF-8 chars presence
	assert.Error(t, err)
}

func AsciiIMEIToBytes(s string) ([]byte, error) {
	var bs []byte
	for _, r := range s {
		size := utf8.RuneLen(r)
		if size == -1 {
			return []byte{}, fmt.Errorf("%s contains non-UTF8 characters", s)
		}
		if size > 1 {
			return []byte{}, fmt.Errorf("%s contains non-ASCII runes", s)
		}
		b := byte(r)
		if b == 0x46 {
			continue
		}
		bs = append(bs, b)
	}
	return bs, nil
}

func TestDecodeSingleRecord(t *testing.T) {
	hd1 := []byte("2480006200111911003418042116225922348310113550543F12980000002D060000000020E028109228661F05010001")
	dst1 := make([]byte, hex.DecodedLen(len(hd1)))
	// will return 8688220402481995 in ascii bytes slice
	hd2, _ := AsciiIMEIToBytes("868822040248195F")
	hd3 := []byte("000001CC0156")
	dst3 := make([]byte, hex.DecodedLen(len(hd3)))
	_, err := hex.Decode(dst1, hd1)
	assert.Nil(t, err)
	_, err = hex.Decode(dst3, hd3)
	assert.Nil(t, err)
	res := append(dst1, hd2...)
	res = append(res, dst3...)
	expectedDecoded := Decoded{
		ProtocolHeader:  "36",
		ProtocolVersion: "25",
		IMEI:            "868822040248195",
		TerminalID:      "8000620011",
		BindVehicleID:   "00000000",
		DeviceType:      1,
		DataType:        1,
		Data: []PALData{
			{
				UtimeMs:               162259,
				Utime:                 0xa2,
				Priority:              0,
				Lat:                   22348310,
				Lng:                   113550543,
				Angle:                 304,
				VisSat:                6,
				Speed:                 33.300000000000004,
				Date:                  "180421",
				Time:                  "162259",
				BatteryLevel:          40,
				CellIdPositionCode:    278014054, //10922866 in hex format
				Mcc:                   460,
				GSMSignalQuality:      0x1F,
				FenceAlarmID:          0x05,
				MNCHighByte:           0x00,
				MNCLowByte:            0x01,
				ExpandedDeviceStatus:  0x01,
				ExpandedDeviceStatus2: 0x01,
				SerialNo:              86,
				Length:                52,
				DeviceStatusParser:    "20E0",
				DirectionIndicator:    "F",
				DeviceStatus: DeviceStatuses{
					baseStationPositioning:     false,
					enterFenceAlarm:            false,
					exitFenceAlarm:             false,
					lockRopeCutAlarm:           false,
					vibrationAlarm:             false,
					platformACKCommandRequired: false,
					lockRopeState:              false,
					motorState:                 false,
					longTimeUnlockingAlarm:     false,
					wrongPasswordAlarm:         false,
					swipeIllegalRFIDCardAlarm:  false,
					lowBatteryAlarm:            false,
					backCoverOpenedAlarm:       false,
					backCoverStatus:            false,
					motorStuckAlarm:            false,
					reserved:                   false,
				},
				Distance: 45,
			},
		},
	}

	// Pass the address of the byte slice to the Decode function
	decoded, err := Decode(&res)
	assert.NoError(t, err)
	assert.NotEmpty(t, decoded)
	assert.Equal(t, expectedDecoded, decoded)
	//dec = 4242 hex = 0x1092
	var expCellId uint16 = 4242
	assert.Equal(t, expCellId, decoded.Data[0].CellId())
	//dec = 10342 hex = 0x2866
	var expLAC uint16 = 10342
	assert.Equal(t, expLAC, decoded.Data[0].LAC())
	val := reflect.DeepEqual(decoded, expectedDecoded)
	assert.True(t, val)
	assert.EqualValues(t, expectedDecoded.Data, decoded.Data)
}

func TestMultiplePosData(t *testing.T) {
	byteData := []byte{
		// mix of hex digits and ascii imei as byte slice
		//2480006200111911003418042116225922348310113550543F12980000002D060000000020E028109228661F05010001868822040248195F000001CC0156
		0x24, 0x80, 0x00, 0x62, 0x00, 0x11, 0x19, 0x11, 0x00, 0x34, 0x18, 0x04, 0x21, 0x16, 0x22, 0x59,
		0x22, 0x34, 0x83, 0x10, 0x11, 0x35, 0x50, 0x54, 0x3f, 0x12, 0x98, 0x00, 0x00, 0x00, 0x2d, 0x06,
		0x00, 0x00, 0x00, 0x00, 0x20, 0xe0, 0x28, 0x10, 0x92, 0x28, 0x66, 0x1f, 0x05, 0x01, 0x00, 0x01,
		0x38, 0x36, 0x38, 0x38, 0x32, 0x32, 0x30, 0x34, 0x30, 0x32, 0x34, 0x38, 0x31, 0x39, 0x35, 0x46,
		0x00, 0x01, 0xcc, 0x01, 0x56,
		//2480006200111911003418042116225922348310113550543F12980000002D060000000020E028109228661F05010001868822040248195F000001CC0156
		0x24, 0x80, 0x00, 0x62, 0x00, 0x11, 0x19, 0x11, 0x00, 0x34, 0x18, 0x04, 0x21, 0x16, 0x22, 0x59,
		0x22, 0x34, 0x83, 0x10, 0x11, 0x35, 0x50, 0x54, 0x3f, 0x12, 0x98, 0x00, 0x00, 0x00, 0x2d, 0x06,
		0x00, 0x00, 0x00, 0x00, 0x20, 0xe0, 0x28, 0x10, 0x92, 0x28, 0x66, 0x1f, 0x05, 0x01, 0x00, 0x01,
		0x38, 0x36, 0x38, 0x38, 0x32, 0x32, 0x30, 0x34, 0x30, 0x32, 0x34, 0x38, 0x31, 0x39, 0x35, 0x46,
		0x00, 0x01, 0xcc, 0x01, 0x56,
		//2480006200111911003418042116225922348310113550543F12980000002D060000000020E028109228661F05010001868822040248195F000001CC0156
		0x24, 0x80, 0x00, 0x62, 0x00, 0x11, 0x19, 0x11, 0x00, 0x34, 0x18, 0x04, 0x21, 0x16, 0x22, 0x59,
		0x22, 0x34, 0x83, 0x10, 0x11, 0x35, 0x50, 0x54, 0x3f, 0x12, 0x98, 0x00, 0x00, 0x00, 0x2d, 0x06,
		0x00, 0x00, 0x00, 0x00, 0x20, 0xe0, 0x28, 0x10, 0x92, 0x28, 0x66, 0x1f, 0x05, 0x01, 0x00, 0x01,
		0x38, 0x36, 0x38, 0x38, 0x32, 0x32, 0x30, 0x34, 0x30, 0x32, 0x34, 0x38, 0x31, 0x39, 0x35, 0x46,
		0x00, 0x01, 0xcc, 0x01, 0x56,
	}
	assert.NotEmpty(t, byteData)

	// Pass the address of the byte slice to the Decode function
	decoded, err := Decode(&byteData)
	assert.Nil(t, err)
	assert.NotEmpty(t, decoded)
	assert.Len(t, decoded.Data, 3)

}

func TestDecodeMultiplePosDataWithHealthcheckAsLast(t *testing.T) {
	byteData := []byte{
		// mix of hex digits and ascii imei as byte slice
		//2480006200111911003418042116225922348310113550543F12980000002D060000000020E028109228661F05010001868822040248195F000001CC0156
		0x24, 0x80, 0x00, 0x62, 0x00, 0x11, 0x19, 0x11, 0x00, 0x34, 0x18, 0x04, 0x21, 0x16, 0x22, 0x59,
		0x22, 0x34, 0x83, 0x10, 0x11, 0x35, 0x50, 0x54, 0x3f, 0x12, 0x98, 0x00, 0x00, 0x00, 0x2d, 0x06,
		0x00, 0x00, 0x00, 0x00, 0x20, 0xe0, 0x28, 0x10, 0x92, 0x28, 0x66, 0x1f, 0x05, 0x01, 0x00, 0x01,
		0x38, 0x36, 0x38, 0x38, 0x32, 0x32, 0x30, 0x34, 0x30, 0x32, 0x34, 0x38, 0x31, 0x39, 0x35, 0x46,
		0x00, 0x01, 0xcc, 0x01, 0x56,
		//2480006200111911003418042116225922348310113550543F12980000002D060000000020E028109228661F05010001868822040248195F000001CC0156
		0x24, 0x80, 0x00, 0x62, 0x00, 0x11, 0x19, 0x11, 0x00, 0x34, 0x18, 0x04, 0x21, 0x16, 0x22, 0x59,
		0x22, 0x34, 0x83, 0x10, 0x11, 0x35, 0x50, 0x54, 0x3f, 0x12, 0x98, 0x00, 0x00, 0x00, 0x2d, 0x06,
		0x00, 0x00, 0x00, 0x00, 0x20, 0xe0, 0x28, 0x10, 0x92, 0x28, 0x66, 0x1f, 0x05, 0x01, 0x00, 0x01,
		0x38, 0x36, 0x38, 0x38, 0x32, 0x32, 0x30, 0x34, 0x30, 0x32, 0x34, 0x38, 0x31, 0x39, 0x35, 0x46,
		0x00, 0x01, 0xcc, 0x01, 0x56,
		//2480006200111911003418042116225922348310113550543F12980000002D060000000020E028109228661F05010001868822040248195F000001CC0156
		0x24, 0x80, 0x00, 0x62, 0x00, 0x11, 0x19, 0x11, 0x00, 0x34, 0x18, 0x04, 0x21, 0x16, 0x22, 0x59,
		0x22, 0x34, 0x83, 0x10, 0x11, 0x35, 0x50, 0x54, 0x3f, 0x12, 0x98, 0x00, 0x00, 0x00, 0x2d, 0x06,
		0x00, 0x00, 0x00, 0x00, 0x20, 0xe0, 0x28, 0x10, 0x92, 0x28, 0x66, 0x1f, 0x05, 0x01, 0x00, 0x01,
		0x38, 0x36, 0x38, 0x38, 0x32, 0x32, 0x30, 0x34, 0x30, 0x32, 0x34, 0x38, 0x31, 0x39, 0x35, 0x46,
		0x00, 0x01, 0xcc, 0x01, 0x56,
		0x28, 0x38, 0x30, 0x30, 0x30, 0x36, 0x32, 0x30, 0x30, 0x31, 0x31, 0x2c, 0x40, 0x4a, 0x54, 0x29,
	}
	assert.NotEmpty(t, byteData)
	// 0 - 0x28 14 - 0x54 15 - 0x29
	// Pass the address of the byte slice to the Decode function
	decoded, err := Decode(&byteData)
	assert.Nil(t, err)
	assert.NotEmpty(t, decoded)
	assert.Equal(t, "8000620011", decoded.TerminalID)
	assert.Len(t, decoded.Data, 3)
	const mcc uint16 = 460
	assert.Equal(t, mcc, decoded.Data[2].Mcc)
}

func TestDecodeMultiplePosDataWithHealthcheckAsFirst(t *testing.T) {
	byteData := []byte{
		//(8000620011,@JT)
		0x28, 0x38, 0x30, 0x30, 0x30, 0x36, 0x32, 0x30, 0x30, 0x31, 0x31, 0x2c, 0x40, 0x4a, 0x54, 0x29,
		// mix of hex digits and ascii imei as byte slice
		//2480006200111911003418042116225922348310113550543F12980000002D060000000020E028109228661F05010001868822040248195F000001CC0156
		0x24, 0x80, 0x00, 0x62, 0x00, 0x11, 0x19, 0x11, 0x00, 0x34, 0x18, 0x04, 0x21, 0x16, 0x22, 0x59,
		0x22, 0x34, 0x83, 0x10, 0x11, 0x35, 0x50, 0x54, 0x3f, 0x12, 0x98, 0x00, 0x00, 0x00, 0x2d, 0x06,
		0x00, 0x00, 0x00, 0x00, 0x20, 0xe0, 0x28, 0x10, 0x92, 0x28, 0x66, 0x1f, 0x05, 0x01, 0x00, 0x01,
		0x38, 0x36, 0x38, 0x38, 0x32, 0x32, 0x30, 0x34, 0x30, 0x32, 0x34, 0x38, 0x31, 0x39, 0x35, 0x46,
		0x00, 0x01, 0xcc, 0x01, 0x56,
		//2480006200111911003418042116225922348310113550543F12980000002D060000000020E028109228661F05010001868822040248195F000001CC0156
		0x24, 0x80, 0x00, 0x62, 0x00, 0x11, 0x19, 0x11, 0x00, 0x34, 0x18, 0x04, 0x21, 0x16, 0x22, 0x59,
		0x22, 0x34, 0x83, 0x10, 0x11, 0x35, 0x50, 0x54, 0x3f, 0x12, 0x98, 0x00, 0x00, 0x00, 0x2d, 0x06,
		0x00, 0x00, 0x00, 0x00, 0x20, 0xe0, 0x28, 0x10, 0x92, 0x28, 0x66, 0x1f, 0x05, 0x01, 0x00, 0x01,
		0x38, 0x36, 0x38, 0x38, 0x32, 0x32, 0x30, 0x34, 0x30, 0x32, 0x34, 0x38, 0x31, 0x39, 0x35, 0x46,
		0x00, 0x01, 0xcc, 0x01, 0x56,
		//2480006200111911003418042116225922348310113550543F12980000002D060000000020E028109228661F05010001868822040248195F000001CC0156
		0x24, 0x80, 0x00, 0x62, 0x00, 0x11, 0x19, 0x11, 0x00, 0x34, 0x18, 0x04, 0x21, 0x16, 0x22, 0x59,
		0x22, 0x34, 0x83, 0x10, 0x11, 0x35, 0x50, 0x54, 0x3f, 0x12, 0x98, 0x00, 0x00, 0x00, 0x2d, 0x06,
		0x00, 0x00, 0x00, 0x00, 0x20, 0xe0, 0x28, 0x10, 0x92, 0x28, 0x66, 0x1f, 0x05, 0x01, 0x00, 0x01,
		0x38, 0x36, 0x38, 0x38, 0x32, 0x32, 0x30, 0x34, 0x30, 0x32, 0x34, 0x38, 0x31, 0x39, 0x35, 0x46,
		0x00, 0x01, 0xcc, 0x01, 0x56,
	}
	assert.NotEmpty(t, byteData)
	// bs[0] = 0x28 bs[14] = 0x54 bs[15] = 0x29
	// Pass the address of the byte slice to the Decode function
	decoded, err := Decode(&byteData)
	assert.Nil(t, err)
	assert.NotEmpty(t, decoded)
	assert.Equal(t, "8000620011", decoded.TerminalID)
	assert.Len(t, decoded.Data, 3)
	const mcc uint16 = 460
	assert.Equal(t, mcc, decoded.Data[0].Mcc)
}

func TestDecodeHealthcheckOnly(t *testing.T) {
	hexData := "28383030303632303031312C404A5429"
	byteData, err := hex.DecodeString(hexData)
	assert.NoError(t, err)
	assert.NotEmpty(t, byteData)
	// bs[0] = 0x28 bs[14] = 0x54 bs[15] = 0x29
	// Pass the address of the byte slice to the Decode function
	decoded, err := Decode(&byteData)
	assert.Nil(t, err)
	assert.NotEmpty(t, decoded)
	assert.Equal(t, "8000620011", decoded.TerminalID)
	assert.Empty(t, decoded.Data)
}
